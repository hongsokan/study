# 참고도서 - [알고리즘 도감](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9791188621125)

## 해당 도서는 'Algorithms'라는 모바일 어플을 기반으로 만든 알고리즘 입문서이다. 
- [Android](https://play.google.com/store/apps/details?id=wiki.algorithm.algorithms&hl=ko&gl=US)
- [iOS](https://apps.apple.com/kr/app/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%8F%84%EA%B0%90/id1047532631)

## 요약
### 자료구조
- 리스트
> 일직선으로 나열된 데이터. 추가 및 삭제에 유리 (링크드 리스트)

- 배열
> 1열로 나열된 데이터. 접근 및 조회에 유리

- 스택
> 흔히 바구니에 데이터가 쌓이는 모습으로 비유. LIFO. push & pop

- 큐
> 대기 행렬. FIFO. enqueue & dequeue

- 해시테이블
> Key & Value. 
> 
> 해시 함수를 통해 Key의 해시값 계산 -> mod 연산.
> 
> 데이터 충돌 시 해당 위치에 리스트로 연결(chaining). 다른 방법으로는 open addressing이 있다.

- 힙
> 트리 구조. 노드에 데이터를 저장하고. 항상 가장 위에 최솟값이 위치한다.
> 
> 자식 노드는 반드시 부모 노드의 숫자보다 커야 함.

- 이진탐색트리
> 트리 구조. 각 노드에 최대 2개의 자식 노드 존재. (자식 노드들이 m개로 확장되는 것이 'B-tree')
> 
> 모든 노드의 값은 왼쪽 가지들보다 크고, 오른쪽 가지들보다 작아야 함.

### 정렬
- 버블
> 오른쪽부터 왼쪽 방향으로 2개씩 비교. O(n^2)

- 선택
> 수열에서 최솟값을 차례대로 검색하고 왼쪽 끝에 있는 숫자와 교체. O(n^2)

- 삽입
> 왼쪽에 정렬이 끝난 수열을 두고, 오른쪽 수열에서 차례대로 최솟값을 꺼내서 왼쪽에 삽입. O(n^2)

- 힙
> 힙 구조(내림차순). 힙 최상단노드(가장 큰 수)를 꺼내 정렬. O(n log n)

- 병합 (합병 정렬)
> 수열을 분할하여 정렬하고 다시 합치는 방법. (분할 정복 알고리즘) O(n log n)

- 퀵
> pivot 값을 설정. pivot 값보다 작거나, 큰 수 두 그룹으로 나누어 정렬하는 방법. (분할 정복 알고리즘) O(n log n)

### 탐색
- 선형
> 순서대로 탐색 O(n)
- 이진
> 정렬된 경우에만 적용 가능.
> 
> 중간에 있는 수를 기준으로 비교 및 탐색 O(log n)

### 그래프
- BFS(Breath, 너비 우선 탐색)
> 가까운 정점부터 탐색 (큐와 같이 사용)

- DFS(Depth, 깊이 우선 탐색)
> 끝까지 탐색한 이후 다음 후보 길 탐색. (스택과 사용)

- 벨먼-포드 알고리즘
> 최단 경로 탐색. (가중치 = 시작 정점 가중치 + 간선의 가중치)

- 다익스트라 알고리즘
> 최단 경로 탐색. (가중치 = 현재 정점의 가중치 + 현재에서 후보로 가는 가중치)
> 
> 마이너스 가중치 불가.

- A*(에이스타)
> 추정 가중치를 설정하여 불필요한 탐색을 방지. (발견적 가중치, heuristic weight)
